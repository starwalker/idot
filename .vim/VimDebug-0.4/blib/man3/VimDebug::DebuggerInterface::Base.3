.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "VimDebug::DebuggerInterface::Base 3"
.TH VimDebug::DebuggerInterface::Base 3 "2008-01-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
VimDebug::DebuggerInterface::Base \- a base class for VimDebug::DebuggerInterface::* modules
.SH "VERSION"
.IX Header "VERSION"
$Id: Debugger.pm 93 2007\-12\-22 21:05:20Z eric $
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   package VimDebug::DebuggerInterface::Perl;
.Ve
.PP
.Vb 10
\&   use IPC::Run qw(start pump finish timeout);
\&   use VimDebug::DebuggerInterface::Base qw(
\&     $COMPILER_ERROR
\&     $RUNTIME_ERROR
\&     $APP_EXITED
\&     $LINE_INFO
\&     $DBGR_READY
\&     $TIME
\&     $DEBUG
\&   );
.Ve
.PP
.Vb 1
\&   @ISA = qw(VimDebug::DebuggerInterface::Base);
.Ve
.PP
.Vb 3
\&   use strict;
\&   use warnings FATAL => all;
\&   use Carp;
.Ve
.PP
.Vb 3
\&   # Implement all the API methods listed in VimDebug::DebuggerInterface.  The
\&   # methods in VimDebug::DebuggerInterface::Base may make the developers life
\&   # simpler.
.Ve
.PP
.Vb 4
\&   sub startDebugger {
\&      my $self = shift or confess;
\&      my $path               = shift or die;
\&      my @commandLineOptions = @_;
.Ve
.PP
.Vb 2
\&      # this regexe aids in parsing debugger output.  it is required.
\&      $self->dbgrPromptRegex($dbgrPromptRegex);
.Ve
.PP
.Vb 3
\&      $self->SUPER::startDebugger("perl -d $path @commandLineOptions");
\&      return undef;
\&   }
.Ve
.PP
.Vb 6
\&   sub next {
\&      my $self = shift or confess;
\&      $self->SUPER::command('next'); # where 'next' is the command accepted by
\&                                     # the debugger in your chosen language.
\&      return undef;
\&   }
.Ve
.PP
.Vb 1
\&   # ...etc
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module extends VimDebug::DebuggerInterface.  It is a helper clase for
developers who wish to implement the VimDebug::DebuggerInterface for the
language of their choice. 
.SH "HELPER METHODS"
.IX Header "HELPER METHODS"
The following methods may (or may not) be useful.  They are only a suggestion.
Note that almost all commands cause debuggers to print a response of some kind
to the terminal.  This output is captured and can be retrieved via the method
\&\fIoutput()\fR listed below.
.Sh "_startDebugger($debuggerInvocation)"
.IX Subsection "_startDebugger($debuggerInvocation)"
$debuggerInvocation is the command used to invoke the debugger.  
.PP
Returns undef (this is subject to change)
=cut
sub _startDebugger {
   my \f(CW$self\fR        = shift or confess;
   my \f(CW$incantation\fR = shift or confess;
   my \f(CW$output\fR;
.PP
.Vb 6
\&   $self->_timeout(timeout($TIME));
\&   $self->dbgr(
\&      start($incantation, 
\&            '<pty<', \e$WRITE,
\&            '>pty>', \e$READ,
\&            $self->_timeout));
.Ve
.PP
.Vb 2
\&   $self->getUntilPrompt();
\&   $self->parseOutput($self->output);
.Ve
.PP
.Vb 2
\&   return undef;
\&}
.Ve
.Sh "_command($command)"
.IX Subsection "_command($command)"
Returns a string
=cut
sub _command {
   my \f(CW$self\fR = shift or die;
   my \f(CW$command\fR = shift or die;
.PP
.Vb 2
\&   # write
\&   $WRITE .= "$command\en";
.Ve
.PP
.Vb 2
\&   # read
\&   $self->getUntilPrompt();
.Ve
.PP
.Vb 7
\&   # parse output
\&   my $output = $self->output;
\&   $self->parseOutput($output);
\&   my $prompt = $self->dbgrPromptRegex;
\&   $output =~ s/$prompt//os;
\&   return $output;
\&}
.Ve
.Sh "_quit($command)"
.IX Subsection "_quit($command)"
Returns undef (this is subject to change)
=cut
sub _quit {
   my \f(CW$self\fR = shift or confess;
   my \f(CW$command\fR = shift or confess;
.PP
.Vb 2
\&   $WRITE .= "$command\en";
\&   $self->dbgr->finish();
.Ve
.PP
.Vb 2
\&   return undef;
\&}
.Ve
.Sh "getUntilPrompt"
.IX Subsection "getUntilPrompt"
Reads output of the child process until the next instance of
\&\f(CW$VimDebug::DebuggerInterface::Base::debuggerPrompt\fR is found.
.PP
Returns undef (this is subject to change)
=cut
sub getUntilPrompt   {
   my \f(CW$self\fR   = shift or die;
   my \f(CW$prompt\fR = \f(CW$self\fR\->dbgrPromptRegex;
   my \f(CW$output\fR = '';
.PP
.Vb 1
\&   $output = $READ; # clear output buffer
.Ve
.PP
.Vb 20
\&   eval {
\&      $self->dbgr->pump() until $READ =~ /$prompt/s;
\&   };
\&   if ($@ =~ /process ended prematurely/ and length($READ) != 0) {
\&      print "$READ\en" if $DEBUG;
\&      $self->dbgr->finish();
\&      undef $@;
\&   }
\&   elsif ($@ =~ /process ended prematurely/) {
\&      print "process ended prematurely\en" if $DEBUG;
\&      $self->dbgr->finish();
\&      undef $@;
\&   }
\&   elsif ($@) {
\&      die $@;
\&   }
\&   $self->_timeout->reset();
\&   $output = $READ;
\&   print "[output][$output]\en" if $DEBUG;
\&   $READ = '';
.Ve
.PP
.Vb 1
\&   $self->output($output);
.Ve
.PP
.Vb 2
\&   return undef;
\&}
.Ve
.Sh "output($output)"
.IX Subsection "output($output)"
Remove ornaments (like <\s-1CTL\-M\s0> or irrelevant error messages or whatever) from
text. 
.PP
Returns \f(CW$output\fR cleansed
=cut
sub output {
   my \f(CW$self\fR = shift or die;
   my \f(CW$output\fR = '';
.PP
.Vb 5
\&   if (@_) {
\&      $output = shift;
\&      $output =~ s///mg;
\&      $self->{output} = $output;
\&   }
.Ve
.PP
.Vb 2
\&   return $self->{output};
\&}
.Ve
.Sh "parseOutput($output)"
.IX Subsection "parseOutput($output)"
Parses the string \f(CW$output\fR.  If possible it sets the \fIfilePath()\fR and \fIlineNumber()\fR
attributes.  
.PP
Returns undef;
=cut
sub parseOutput {
   my \f(CW$self\fR   = shift or die;
   my \f(CW$output\fR = shift or die;
.PP
.Vb 2
\&   $self->parseForLineNumber($output);
\&   $self->parseForFilePath($output);
.Ve
.PP
.Vb 2
\&   return undef;
\&}
.Ve
.Sh "parseForLineNumber($output)"
.IX Subsection "parseForLineNumber($output)"
Parses \f(CW$output\fR and sets \f(CW$self\fR\->lineNumber($number) if possible.
.PP
Returns undef;
=cut
sub parseForLineNumber {
   my \f(CW$self\fR = shift or die;
   confess \*(L"developers should implement this method in their modules\*(R";
   return undef;
}
.Sh "parseForFilePath($output)"
.IX Subsection "parseForFilePath($output)"
Parses \f(CW$output\fR and sets \f(CW$self\fR\->filePath($path) if possible.
.PP
Returns undef
=cut
sub parseForFilePath {
   my \f(CW$self\fR = shift or die;
   confess \*(L"developers should implement this method in their modules\*(R";
   return undef;
}
.Sh "lineNumber($number)"
.IX Subsection "lineNumber($number)"
If \f(CW$number\fR parameter is used, the lineNumber class attribute is set using that
value.  If no parameters are passed, the current value of the lineNumber class
attribute is returned.
.Sh "filePath($path)"
.IX Subsection "filePath($path)"
If \f(CW$path\fR parameter is used, the filePath class attribute is set using that
value.  If no parameters are passed, the current value of the filePath class
attribute is returned.
.Sh "dbgrPromptRegex($regex)"
.IX Subsection "dbgrPromptRegex($regex)"
If \f(CW$regex\fR parameter is used, the dbgrPromptRegex class attribute is set using that
value.  If no parameters are passed, the current value of the dbgrPromptRegex class
attribute is returned.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Devel::ebug, perldebguts
.SH "AUTHOR"
.IX Header "AUTHOR"
Eric Johnson, cpan at iijo : :dot: : org
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2003 \- 3090, Eric Johnson
.PP
This module is \s-1GPL\s0.
